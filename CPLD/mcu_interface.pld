Name     MCU_6502_Interface;
PartNo   001;
Date     2024-01-09;
Revision 01;
Designer ;
Company  ;
Assembly ;
Location ;
Device   v750c;

/*
 * 6502-to-MCU Bus Interface CPLD
 * Target: ATF750LVC (PLCC28)
 *
 * Provides two 8-bit data registers (TX and RX) with full handshaking
 * for asynchronous communication between 65C02 CPU and RP2040 MCU.
 *
 * External latches:
 *   74HC574 #1 (TX): MCU -> CPU data path
 *   74HC574 #2 (RX): CPU -> MCU data path
 *   74HC574 #3 (Status): Status bits to CPU
 *
 * IMPORTANT: MCU firmware must pulse RX_ACK at startup to initialize
 * RX_READY to 1 (device powers up with registers at 0).
 *
 * Reference: 6502_mcu_interface_spec.md
 */

/* ======================== INPUT PINS ======================== */
PIN 1  = CLK;       /* Global clock - tie to GND (not used) */
PIN 2  = PHI2;      /* 6502 system clock */
PIN 3  = CS_N;      /* Chip select from address decoder (active low) */
PIN 4  = RW;        /* 6502 Read/Write: 1=read, 0=write */
PIN 5  = A0;        /* Register select: 0=data (RX/TX), 1=status */
PIN 6  = TX_LOAD;   /* MCU pulses high to load TX latch */
PIN 7  = RX_ACK;    /* MCU pulses high to acknowledge RX read */

/* ======================== OUTPUT PINS ======================= */
PIN 18 = TX_OE_N;       /* Enable TX latch outputs onto 6502 bus (active low) */
PIN 19 = RX_CLK;        /* Clock CPU write data into RX latch */
PIN 20 = STATUS_OE_N;   /* Enable status latch outputs onto 6502 bus (active low) */
PIN 21 = STATUS_CLK;    /* Clock status bits into status latch */
PIN 22 = TX_AVAIL;      /* To status latch D7: MCU data available */
PIN 23 = RX_READY;      /* To status latch D6: RX register empty */
PIN 24 = DATA_TAKEN;    /* To MCU: CPU has read TX byte */
PIN 25 = DATA_WRITTEN;  /* To MCU: CPU has written RX byte */

/* ======================== BURIED REGISTERS =================== */
/* State flip-flops use buried nodes since output pins 22-25 may not
 * support registered outputs on ATF750LVC. Output pins are driven
 * combinatorially from these internal registers. */
NODE tx_avail_reg;
NODE rx_ready_reg;
NODE data_taken_reg;
NODE data_written_reg;

/* ======================== INTERMEDIATE TERMS ================ */
/* CPU bus cycle decode - active during valid portion of bus cycle */
TX_READ    = PHI2 & !CS_N & !A0 & RW;   /* CPU reading TX data register */
RX_WRITE   = PHI2 & !CS_N & !A0 & !RW;  /* CPU writing RX data register */
STATUS_READ = PHI2 & !CS_N & A0 & RW;   /* CPU reading status register */

/* ======================== COMBINATORIAL OUTPUTS ============= */

/*
 * TX_OE_N: Enable TX latch outputs when CPU reads TX register
 * Active low output - directly drives 74HC574 OE pin
 */
TX_OE_N = !TX_READ;

/*
 * RX_CLK: Generate clock edge to capture CPU data into RX latch
 * 74HC574 latches on rising edge
 * Signal rises when RX_WRITE becomes true (PHI2 rises during write cycle)
 */
RX_CLK = RX_WRITE;

/*
 * STATUS_OE_N: Enable status latch outputs when CPU reads status
 * Active low output - directly drives 74HC574 OE pin
 */
STATUS_OE_N = !STATUS_READ;

/*
 * STATUS_CLK: Clock status register to capture TX_AVAIL and RX_READY
 * Using inverted PHI2 ensures status is captured on PHI2 falling edge,
 * so values are stable well before the next CPU read on PHI2 rising edge.
 */
STATUS_CLK = !PHI2;

/* ======================== BURIED STATE REGISTERS ============ */
/*
 * Handshake state flip-flops using asynchronous set/reset.
 * These use buried nodes (internal registers) because pins 22-25
 * are combinatorial-only on the ATF750LVC.
 *
 * These respond immediately to MCU pulse signals (TX_LOAD, RX_ACK) and
 * CPU bus operations (TX_READ, RX_WRITE). The D input holds the current
 * value to prevent any clock edge from disturbing the state.
 *
 * TIMING NOTE: TX_LOAD and RX_ACK must be brief pulses from MCU.
 * The async reset has priority if both set and reset are asserted.
 */

/*
 * tx_avail_reg: Indicates MCU has sent data for CPU to read
 *   Set:   MCU pulses TX_LOAD (new data loaded into TX latch)
 *   Clear: CPU reads TX register (data taken)
 *   Power-on: 0 (no data available)
 */
tx_avail_reg.ap = TX_LOAD;
tx_avail_reg.ar = TX_READ;
tx_avail_reg.d  = tx_avail_reg;

/*
 * rx_ready_reg: Indicates RX register is empty, CPU may write
 *   Set:   MCU pulses RX_ACK (acknowledges previous byte)
 *   Clear: CPU writes RX register (new data pending for MCU)
 *   Power-on: 0 (device default), MCU must pulse RX_ACK at init
 */
rx_ready_reg.ap = RX_ACK;
rx_ready_reg.ar = RX_WRITE;
rx_ready_reg.d  = rx_ready_reg;

/*
 * data_taken_reg: Signals to MCU that CPU has read the TX byte
 *   Set:   CPU reads TX register
 *   Clear: MCU pulses TX_LOAD (loading next byte)
 *   Power-on: 0
 */
data_taken_reg.ap = TX_READ;
data_taken_reg.ar = TX_LOAD;
data_taken_reg.d  = data_taken_reg;

/*
 * data_written_reg: Signals to MCU that CPU has written an RX byte
 *   Set:   CPU writes RX register
 *   Clear: MCU pulses RX_ACK (MCU has read the byte)
 *   Power-on: 0
 */
data_written_reg.ap = RX_WRITE;
data_written_reg.ar = RX_ACK;
data_written_reg.d  = data_written_reg;

/* ======================== STATE OUTPUT PINS ================= */
/* Drive output pins combinatorially from buried registers */
TX_AVAIL     = tx_avail_reg;
RX_READY     = rx_ready_reg;
DATA_TAKEN   = data_taken_reg;
DATA_WRITTEN = data_written_reg;
