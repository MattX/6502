;
; PIO-based 6502 Bus Interface - Receive Only (Safe Test Mode)
;
; Target: RP2350
;
; This is a minimal receive-only version for safe testing.
; The MCU NEVER drives the data bus - only monitors writes from the CPU.
;
; Pin mapping:
;   GPIO 0:     CS_N   - chip select (active low)
;   GPIO 1:     PHI2   - 6502 system clock
;   GPIO 6:     RW     - read/write (1=read, 0=write)
;   GPIO 22-29: D[7:0] - data bus (INPUT ONLY)
;
; This version ignores RW=1 (reads) entirely. When the CPU reads, it will
; see whatever is on the bus (likely floating/pulled values), but that's
; fine for testing - we just won't respond.
;
; Note: in_base is 0, so we read GPIO 0-29 together and extract:
;   - bit 0 = CS_N
;   - bit 6 = RW
;   - bits 22-29 = D[7:0]
;

.program bus_interface_rx_only

.define PUBLIC PIN_CS_N  0
.define PUBLIC PIN_PHI2  1
.define PUBLIC PIN_RW    6
.define PUBLIC PIN_D0    22

.wrap_target
wait_cycle:
    wait 1 gpio PIN_PHI2        ; Wait for PHI2 to go high

    ; Read all pins: GPIO 0-29 into ISR
    in pins, 30
    mov y, isr                  ; Save full pin state in y
    in null, 32                 ; Clear ISR

    ; Check CS_N (bit 0): if 1, we're not selected
    mov osr, y
    out x, 1                    ; x = bit 0 (CS_N)
    jmp x-- wait_phi2_low       ; If CS_N=1, not selected, skip

    ; CS_N=0, we're selected. Check RW (bit 6)
    mov osr, y
    out null, 6                 ; Discard bits 0-5
    out x, 1                    ; x = bit 6 (RW)
    jmp x-- wait_phi2_low       ; RW=1 -> read, ignore (we don't drive the bus)

    ; === RW=0: CPU writing to MCU ===
do_write:
    ; Extract data bits 22-29 from y
    mov osr, y
    out null, 22                ; Discard bits 0-21
    out isr, 8                  ; ISR = bits 22-29 (D[7:0])
    push                        ; Send to RX FIFO
    ; Fall through to wait

wait_phi2_low:
    wait 0 gpio PIN_PHI2        ; Wait for PHI2 to go low
.wrap

% c-sdk {
#include "hardware/gpio.h"

// Control pin definitions
#define BUS_PIN_CS_N    0
#define BUS_PIN_PHI2    1
#define BUS_PIN_RW      6

// Data bus pins (consecutive, INPUT ONLY)
#define BUS_PIN_D0      22
#define BUS_PIN_D_COUNT 8

static inline void bus_interface_rx_only_program_init(PIO pio, uint sm, uint offset) {
    pio_sm_config c = bus_interface_rx_only_program_get_default_config(offset);

    // IN pins start at GPIO 0 so we can read all control + data pins
    sm_config_set_in_pins(&c, 0);
    sm_config_set_in_shift(&c, true, false, 32);  // Shift right, no autopush

    // Initialize control pins as inputs
    gpio_init(BUS_PIN_PHI2);
    gpio_set_dir(BUS_PIN_PHI2, GPIO_IN);
    gpio_set_pulls(BUS_PIN_PHI2, false, false);

    gpio_init(BUS_PIN_CS_N);
    gpio_set_dir(BUS_PIN_CS_N, GPIO_IN);
    gpio_set_pulls(BUS_PIN_CS_N, true, false);  // Pull-up (active low)

    gpio_init(BUS_PIN_RW);
    gpio_set_dir(BUS_PIN_RW, GPIO_IN);
    gpio_set_pulls(BUS_PIN_RW, true, false);    // Pull-up (read by default)

    // Initialize data bus pins as INPUTS - NEVER configure as outputs!
    for (int i = 0; i < BUS_PIN_D_COUNT; i++) {
        uint pin = BUS_PIN_D0 + i;
        gpio_init(pin);
        gpio_set_dir(pin, GPIO_IN);
        gpio_set_pulls(pin, false, false);
    }

    // Run at full system clock
    sm_config_set_clkdiv(&c, 1.0f);

    // Initialize state machine
    pio_sm_init(pio, sm, offset, &c);
}

static inline void bus_interface_rx_only_enable(PIO pio, uint sm) {
    pio_sm_set_enabled(pio, sm, true);
}

static inline void bus_interface_rx_only_disable(PIO pio, uint sm) {
    pio_sm_set_enabled(pio, sm, false);
}
%}
