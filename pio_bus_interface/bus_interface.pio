;
; PIO-based 6502 Bus Interface (Simplified Protocol)
;
; This PIO program implements a byte-stream interface between a 6502 CPU
; and an RP2040, replacing the CPLD + latches design with pure PIO logic.
;
; Pin mapping:
;   GPIO 0-7:   D[7:0] - bidirectional data bus
;   GPIO 8:     PHI2   - 6502 system clock
;   GPIO 9:     CS_N   - chip select (directly controls JMP PIN)
;   GPIO 10:    RW     - read/write (1=read, 0=write)
;
; Note: A0 is NOT used. Status is implicit in the data stream.
;
; Protocol:
;   Write (CPU -> MCU): CPU writes bytes, PIO pushes to RX FIFO
;   Read (MCU -> CPU):  PIO pulls from TX FIFO, CPU reads bytes
;                       If TX FIFO empty, returns 0xFF (not ready)
;
; Timing analysis (at 125MHz PIO clock):
;   - Read path: 10 cycles = 80ns (20ns margin at 5MHz)
;   - Write path: 8 cycles = 64ns (36ns margin at 5MHz)
;

.program bus_interface

.wrap_target
wait_cycle:
    wait 1 gpio 8               ; [1] Wait for PHI2 to go high
    jmp pin wait_phi2_low       ; [2] CS_N=1? Not selected, skip

    ; Decode RW (GPIO 10)
    mov osr, pins               ; [3] OSR = all GPIO pin states
    out null, 10                ; [4] Discard bits 0-9
    out x, 1                    ; [5] x = RW (bit 10)
    jmp !x do_write             ; [6] RW=0 -> write

    ; === RW=1: CPU reading from MCU ===
do_read:
    pull noblock                ; [7] Get from TX FIFO (keeps OSR if empty)
    out pins, 8                 ; [8] Drive data onto D[7:0]
    mov osr, ~null              ; [9] OSR = 0xFFFFFFFF
    out pindirs, 8              ; [10] Enable outputs
    wait 0 gpio 8               ; [11] Hold until PHI2 falls
    mov osr, null               ; [12] OSR = 0
    out pindirs, 8              ; [13] Disable outputs (high-Z)
    mov osr, ~null              ; [14] Reset OSR to 0xFF for next empty read
    jmp wait_cycle              ; [15]

    ; === RW=0: CPU writing to MCU ===
do_write:
    in pins, 8                  ; [16] Sample D[7:0] into ISR
    push                        ; [17] Send to RX FIFO

wait_phi2_low:
    wait 0 gpio 8               ; [18] Wait for PHI2 to go low
.wrap

% c-sdk {
#include "hardware/clocks.h"
#include "hardware/gpio.h"

// Pin definitions
#define BUS_PIN_D0      0
#define BUS_PIN_D7      7
#define BUS_PIN_PHI2    8
#define BUS_PIN_CS_N    9
#define BUS_PIN_RW      10

static inline void bus_interface_program_init(PIO pio, uint sm, uint offset) {
    pio_sm_config c = bus_interface_program_get_default_config(offset);

    // Configure pin mappings
    sm_config_set_in_pins(&c, BUS_PIN_D0);      // IN starts at D0
    sm_config_set_out_pins(&c, BUS_PIN_D0, 8);  // OUT to D[7:0] (pins and pindirs)
    sm_config_set_jmp_pin(&c, BUS_PIN_CS_N);    // JMP PIN uses CS_N

    // Configure shift directions (right shift for both, which is default)
    sm_config_set_out_shift(&c, true, false, 32);  // Right shift, no autopull
    sm_config_set_in_shift(&c, true, false, 8);    // Right shift, no autopush, 8 bits

    // Initialize GPIO pins
    // Data bus D[7:0]: start as inputs (directly controlled by PIO)
    for (int i = BUS_PIN_D0; i <= BUS_PIN_D7; i++) {
        pio_gpio_init(pio, i);
        gpio_set_pulls(i, false, false);  // No pulls on data bus
    }

    // Control inputs
    gpio_init(BUS_PIN_PHI2);
    gpio_set_dir(BUS_PIN_PHI2, GPIO_IN);
    gpio_set_pulls(BUS_PIN_PHI2, false, false);

    gpio_init(BUS_PIN_CS_N);
    gpio_set_dir(BUS_PIN_CS_N, GPIO_IN);
    gpio_set_pulls(BUS_PIN_CS_N, true, false);  // Pull-up (deselected by default)

    gpio_init(BUS_PIN_RW);
    gpio_set_dir(BUS_PIN_RW, GPIO_IN);
    gpio_set_pulls(BUS_PIN_RW, true, false);    // Pull-up (read by default)

    // Set initial pin directions for PIO (all inputs)
    pio_sm_set_consecutive_pindirs(pio, sm, BUS_PIN_D0, 8, false);

    // Run at full system clock for best timing margin
    sm_config_set_clkdiv(&c, 1.0f);

    // Load configuration
    pio_sm_init(pio, sm, offset, &c);

    // Pre-load OSR with 0xFFFFFFFF so empty FIFO reads return 0xFF
    // mov osr, ~null
    pio_sm_exec(pio, sm, pio_encode_mov_not(pio_osr, pio_null));
}

static inline void bus_interface_enable(PIO pio, uint sm) {
    pio_sm_set_enabled(pio, sm, true);
}

static inline void bus_interface_disable(PIO pio, uint sm) {
    pio_sm_set_enabled(pio, sm, false);
}
%}
