;
; PIO-based 6502 Bus Interface (Simplified Protocol)
;
; Target: RP2350
;
; Pin mapping:
;   GPIO 0:     CS_N   - chip select (active low)
;   GPIO 1:     PHI2   - 6502 system clock
;   GPIO 6:     RW     - read/write (1=read, 0=write)
;   GPIO 22-29: D[7:0] - data bus
;
; Protocol (0xFF sentinel, no A0):
;   Write (CPU -> MCU): [device] [length] [data...]
;   Read (MCU -> CPU):  [device|0x80] -> poll until != 0xFF, that's length, then read data
;
; The PIO uses `pull noblock` which keeps OSR unchanged when FIFO is empty.
; OSR is initialized to 0xFF, so reads return 0xFF (not ready) until data is available.
;
; Note: in_base is 0, so we read GPIO 0-29 together and extract:
;   - bit 0 = CS_N
;   - bit 6 = RW
;   - bits 22-29 = D[7:0]
;

.program bus_interface

.define PUBLIC PIN_CS_N  0
.define PUBLIC PIN_PHI2  1
.define PUBLIC PIN_RW    6
.define PUBLIC PIN_D0    22

.wrap_target
wait_cycle:
    wait 1 gpio PIN_PHI2        ; Wait for PHI2 to go high

    ; Read all pins: GPIO 0-29 into ISR
    in pins, 30
    mov y, isr                  ; Save full pin state in y
    in null, 32                 ; Clear ISR

    ; Check CS_N (bit 0): if 1, we're not selected
    mov osr, y
    out x, 1                    ; x = bit 0 (CS_N)
    jmp x-- wait_phi2_low       ; If CS_N=1, not selected, skip

    ; CS_N=0, we're selected. Check RW (bit 6)
    mov osr, y
    out null, 6                 ; Discard bits 0-5
    out x, 1                    ; x = bit 6 (RW)
    jmp x-- do_read             ; RW=1 -> read

    ; === RW=0: CPU writing to MCU ===
do_write:
    ; Extract data bits 22-29 from y
    mov osr, y
    out null, 22                ; Discard bits 0-21
    out isr, 8                  ; ISR = bits 22-29 (D[7:0])
    push                        ; Send to RX FIFO
    jmp wait_phi2_low

    ; === RW=1: CPU reading from MCU ===
do_read:
    pull noblock               ; Get data from TX FIFO (or keep 0xFF sentinel)
    out pins, 8                ; Set up data on pin output registers

    ; Enable data pins as outputs
    mov osr, ~null             ; OSR = 0xFFFFFFFF
    out pindirs, 8             ; Enable outputs on GPIO 22-29

    wait 0 gpio PIN_PHI2       ; Wait for PHI2 to fall

    ; Set data pins back to inputs (high-Z)
    mov osr, null              ; OSR = 0
    out pindirs, 8             ; Disable outputs on GPIO 22-29

    ; Reload sentinel value for next read
    mov osr, ~null             ; OSR = 0xFFFFFFFF (so pull noblock returns 0xFF)
    jmp wait_cycle

wait_phi2_low:
    wait 0 gpio PIN_PHI2       ; Wait for PHI2 to go low
.wrap

% c-sdk {
#include "hardware/gpio.h"

// Control pin definitions
#define BUS_PIN_CS_N    0
#define BUS_PIN_PHI2    1
#define BUS_PIN_RW      6

// Data bus pins (consecutive for PIO)
#define BUS_PIN_D0      22
#define BUS_PIN_D_COUNT 8

static inline void bus_interface_program_init(PIO pio, uint sm, uint offset) {
    pio_sm_config c = bus_interface_program_get_default_config(offset);

    // IN pins start at GPIO 0 so we can read all control + data pins
    sm_config_set_in_pins(&c, 0);
    sm_config_set_in_shift(&c, true, false, 32);  // Shift right, no autopush

    // OUT pins start at D0 (GPIO 22) for data bus writes
    sm_config_set_out_pins(&c, BUS_PIN_D0, BUS_PIN_D_COUNT);
    sm_config_set_out_shift(&c, true, false, 32);  // Shift right, no autopull

    // Initialize control pins as inputs
    gpio_init(BUS_PIN_PHI2);
    gpio_set_dir(BUS_PIN_PHI2, GPIO_IN);
    gpio_set_pulls(BUS_PIN_PHI2, false, false);

    gpio_init(BUS_PIN_CS_N);
    gpio_set_dir(BUS_PIN_CS_N, GPIO_IN);
    gpio_set_pulls(BUS_PIN_CS_N, true, false);  // Pull-up (active low)

    gpio_init(BUS_PIN_RW);
    gpio_set_dir(BUS_PIN_RW, GPIO_IN);
    gpio_set_pulls(BUS_PIN_RW, true, false);    // Pull-up (read by default)

    // Initialize data bus pins
    for (int i = 0; i < BUS_PIN_D_COUNT; i++) {
        uint pin = BUS_PIN_D0 + i;
        gpio_init(pin);
        gpio_set_dir(pin, GPIO_IN);  // Start as input (high-Z)
        gpio_set_pulls(pin, false, false);
        pio_gpio_init(pio, pin);     // Hand pin to PIO
    }

    // Run at full system clock
    sm_config_set_clkdiv(&c, 1.0f);

    // Initialize state machine
    pio_sm_init(pio, sm, offset, &c);

    // Pre-load OSR with 0xFF sentinel
    pio_sm_put(pio, sm, 0xFFFFFFFF);
    pio_sm_exec(pio, sm, pio_encode_pull(false, false));
}

static inline void bus_interface_enable(PIO pio, uint sm) {
    pio_sm_set_enabled(pio, sm, true);
}

static inline void bus_interface_disable(PIO pio, uint sm) {
    pio_sm_set_enabled(pio, sm, false);
}
%}
