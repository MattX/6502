;
; PIO-based 6502 Bus Interface (Simplified Protocol)
;
; Pin mapping (directly controls jmp pin/wait gpio):
;   GPIO 0:     CS_N   - chip select (directly controls JMP PIN)
;   GPIO 1:     PHI2   - 6502 system clock
;   GPIO 6:     RW     - read/write (1=read, 0=write)
;
; Data bus pins (directly via separate GPIO, non-consecutive):
;   D0=GPIO26, D1=GPIO27, D2=GPIO28, D3=GPIO29
;   D4=GPIO24, D5=GPIO25, D6=GPIO18, D7=GPIO19
;
; Note: Because data pins are non-consecutive, this implementation reads/writes
; raw GPIO values. The C code handles bit extraction and placement.
;
; Protocol:
;   Write (CPU -> MCU): CPU writes bytes, PIO signals, C extracts data bits
;   Read (MCU -> CPU):  C prepares GPIO, PIO enables outputs, waits, disables
;

.program bus_interface

.define PUBLIC PIN_PHI2  1
.define PUBLIC PIN_CS_N  0
.define PUBLIC PIN_RW    6

.wrap_target
wait_cycle:
    wait 1 gpio PIN_PHI2        ; Wait for PHI2 to go high
    jmp pin wait_phi2_low       ; CS_N=1? Not selected, skip

    ; Check RW (GPIO 6)
    in pins, 7                  ; Read GPIO 0-6 into ISR
    mov x, isr
    set y, 1
    in null, 32                 ; Clear ISR for next use

    ; Extract bit 6 (RW) - shift right by 6, mask with 1
    ; x contains GPIO[6:0], we want bit 6
    ; Use scratch registers to check bit 6
    mov osr, x
    out null, 6                 ; Discard bits 0-5
    out x, 1                    ; x = bit 6 = RW
    jmp !x do_write             ; RW=0 -> write

    ; === RW=1: CPU reading from MCU ===
do_read:
    irq wait 0                  ; Signal C code to prepare data & enable outputs
    wait 0 gpio PIN_PHI2        ; Wait for PHI2 to fall
    irq wait 1                  ; Signal C code to disable outputs
    jmp wait_cycle

    ; === RW=0: CPU writing to MCU ===
do_write:
    irq set 2                   ; Signal C code: write cycle, read GPIO now
    ; Fall through to wait

wait_phi2_low:
    wait 0 gpio PIN_PHI2        ; Wait for PHI2 to go low
.wrap

% c-sdk {
#include "hardware/gpio.h"

// Control pin definitions
#define BUS_PIN_CS_N    0
#define BUS_PIN_PHI2    1
#define BUS_PIN_RW      6

// Data bus pin definitions (directly accessed via GPIO)
#define BUS_PIN_D0      26
#define BUS_PIN_D1      27
#define BUS_PIN_D2      28
#define BUS_PIN_D3      29
#define BUS_PIN_D4      24
#define BUS_PIN_D5      25
#define BUS_PIN_D6      18
#define BUS_PIN_D7      19

static const uint8_t bus_data_pins[8] = {
    BUS_PIN_D0, BUS_PIN_D1, BUS_PIN_D2, BUS_PIN_D3,
    BUS_PIN_D4, BUS_PIN_D5, BUS_PIN_D6, BUS_PIN_D7
};

// Read data byte from GPIO pins
static inline uint8_t bus_read_data_pins(void) {
    uint32_t all_pins = gpio_get_all();
    uint8_t data = 0;
    data |= ((all_pins >> BUS_PIN_D0) & 1) << 0;
    data |= ((all_pins >> BUS_PIN_D1) & 1) << 1;
    data |= ((all_pins >> BUS_PIN_D2) & 1) << 2;
    data |= ((all_pins >> BUS_PIN_D3) & 1) << 3;
    data |= ((all_pins >> BUS_PIN_D4) & 1) << 4;
    data |= ((all_pins >> BUS_PIN_D5) & 1) << 5;
    data |= ((all_pins >> BUS_PIN_D6) & 1) << 6;
    data |= ((all_pins >> BUS_PIN_D7) & 1) << 7;
    return data;
}

// Write data byte to GPIO pins
static inline void bus_write_data_pins(uint8_t data) {
    uint32_t set_mask = 0, clr_mask = 0;
    for (int i = 0; i < 8; i++) {
        if (data & (1 << i)) {
            set_mask |= (1u << bus_data_pins[i]);
        } else {
            clr_mask |= (1u << bus_data_pins[i]);
        }
    }
    gpio_set_mask(set_mask);
    gpio_clr_mask(clr_mask);
}

// Set data pins as outputs
static inline void bus_data_pins_output(void) {
    for (int i = 0; i < 8; i++) {
        gpio_set_dir(bus_data_pins[i], GPIO_OUT);
    }
}

// Set data pins as inputs (high-Z)
static inline void bus_data_pins_input(void) {
    for (int i = 0; i < 8; i++) {
        gpio_set_dir(bus_data_pins[i], GPIO_IN);
    }
}

static inline void bus_interface_program_init(PIO pio, uint sm, uint offset) {
    pio_sm_config c = bus_interface_program_get_default_config(offset);

    // JMP PIN uses CS_N
    sm_config_set_jmp_pin(&c, BUS_PIN_CS_N);

    // IN pins start at GPIO 0 for reading control signals
    sm_config_set_in_pins(&c, 0);
    sm_config_set_in_shift(&c, true, false, 32);

    // Initialize control pins
    gpio_init(BUS_PIN_PHI2);
    gpio_set_dir(BUS_PIN_PHI2, GPIO_IN);
    gpio_set_pulls(BUS_PIN_PHI2, false, false);

    gpio_init(BUS_PIN_CS_N);
    gpio_set_dir(BUS_PIN_CS_N, GPIO_IN);
    gpio_set_pulls(BUS_PIN_CS_N, true, false);  // Pull-up

    gpio_init(BUS_PIN_RW);
    gpio_set_dir(BUS_PIN_RW, GPIO_IN);
    gpio_set_pulls(BUS_PIN_RW, true, false);    // Pull-up

    // Initialize data bus pins as inputs
    for (int i = 0; i < 8; i++) {
        gpio_init(bus_data_pins[i]);
        gpio_set_dir(bus_data_pins[i], GPIO_IN);
        gpio_set_pulls(bus_data_pins[i], false, false);
    }

    sm_config_set_clkdiv(&c, 1.0f);
    pio_sm_init(pio, sm, offset, &c);
}

static inline void bus_interface_enable(PIO pio, uint sm) {
    pio_sm_set_enabled(pio, sm, true);
}

static inline void bus_interface_disable(PIO pio, uint sm) {
    pio_sm_set_enabled(pio, sm, false);
}
%}
